---
layout:        post
title:         "Flask Web | 使用上下文"
subtitle:      ""
author:        "Haauleon"
header-img:    "img/in-post/post-flask/bg.jpeg"
header-mask:   0.4
catalog:       true
tags:
    - Flask
    - Python
    - Web开发
---

> 本篇所有操作均在基于 Ubuntu 16.04 LTS 的虚拟机下完成，且使用 Vagrant 来操作虚拟机系统，虚拟机系统 VirtualBox Version: 7.0 

<br>
<br>

### 一、上下文
环境准备：     
Python 2.7.11+      
pip==9.0.3     
flask==0.11.1   
httpie==0.9.4     

&emsp;&emsp;应用上下文的典型应用场景是缓存一些在发生请求之前要使用到的资源，比如生成数据库连接和缓存一些对象。     

&emsp;&emsp;请求上下文发生在 HTTP 请求开始，WSGI Server 调用 `Flask.__call__()` 之后。     

&emsp;&emsp;应用上下文并不是应用启动后生成的唯一上下文，应用上下文和请求上下文的关系如下：     
```python
class RequestContext(object):
    self._implicit_app_ctx_stack = []

    def push(self):
        # some stuff
        app_ctx = _app_ctx_stack.top
        if app_ctx is None or app_ctx.app != self.app:
            app_ctx = self.app.app_context()
            app_ctx.push()
            self._implicit_app_ctx_stack.append(app_ctx)
        # some other stuff
```

&emsp;&emsp;也就是说应用上下文是被动的在推入请求上下文的过程中生成的，在请求结束的时候，也会把请求上下文弹出：     
```python
class RequestContext(object):
    def pop(self, exc=_sentinel):
        app_ctx = self._implicit_app_ctx_stack.pop()
        try:
            # some stuff
            if app_ctx is not None:
                app_ctx.pop(exc)
```

&emsp;&emsp;也就是说，事实上在 Web 应用环境中，请求上下文和应用上下文是一一对应的。请求上下文和应用上下文都是本地线程的，那么区分它们有什么意义呢？    
- 使用中间件 DispatcherMiddleware，支持多个 app 共存。就像 request 一样，在多 app 情况下之前也要保证 app 之间的隔离。    
- 非 Web 模式下。比如进行测试，一个应用上下文可以有多个请求上下文。但是不能执行 pop 方法，或者使用 with 语句（`__exit__` 中会自动执行 pop 方法）。


<br>
<br>

### 二、使用上下文
&emsp;&emsp;Flask 中有 4 个上下文变量：     
- flask.current_app: 应用上下文。它是当前 app 实例对象。    
- flask.g: 应用上下文。处理请求时用作临时存储的对象。    
- flask.request: 请求上下文。它封装了客户端发出的 HTTP 请求中的内容。   
- flask.session: 请求上下文。它存储了用户会话。    

&emsp;&emsp;其中最常见的就是 flask.g 和 flask.request。   

<br>

#### 1、flask.request
&emsp;&emsp;以下代码段是先引用了 flask.request，但是直到用户访问了 `/people/` 的时候才通过 request.args.get() 方法获取请求的参数值。试想一下，在引用 flask.request 时，倘若此时还没有用户访问 `/people/`，也就是还没有用户发送 `/people/` 请求，那么这个请求的上下文是怎么获得的呢？       
```python
from flask import Flask, request
app = Flask(__name__)


@app.route('/people/')
def people():
    name = request.args.get('name')
```

&emsp;&emsp;flask.request 就是一个 LocalProxy 实例，这个实例是用来获取名为 _request_ctx_stack 的栈顶对象。以下代码逻辑能正常使用，其流程如下：     
1. 用户访问 /people/ 产生请求   
2. 在发生请求的过程中向 _request_ctx_stack 推入这个请求上下文的对象，它会变成栈顶。request 就会成为这个请求的上下文，其包含了这次请求相关的信息和数据     
3. 在视图函数 people() 中使用 request 就可以使用 request.args.get() 获取请求的参数值 name 了   

```python
# coding=utf-8
from functools import partial
from werkzeug.local import LocalStack, LocalProxy

_request_ctx_stack = LocalStack()


def _lookup_req_object(name):
    top = _request_ctx_stack.top
    if top is None:
        raise RuntimeError('working outside of request context')
    return getattr(top, name)


request = LocalProxy(partial(_lookup_req_object, 'request'))
```

&emsp;&emsp;设想一下，如果不使用 LocalStack 和 LocalProxy 的话，要想让视图函数 people() 访问到请求对象，就只能将其作为参数，一步步传入视图函数中。这样做的缺点是会让每个视图函数都增加一个 request 参数，而 Flask 巧妙地使用上下文把某些对象变为全局可访问（实际上是特定环境的局部对象的代理），每个线程看到的上下文对象确是不同的，这样就巧妙地解决了这个问题。

<br>
<br>

#### 2、添加上下文的钩子
